
§§ Importação de módulos
io evocare;

§§ Declaração de funções
formula () saudacao --> scriptum {
    "Olá, mundo!" redire;
}

formula (x atomus | y atomus) soma --> atomus {
    (x + y) redire;
}

§§ Função principal
main () Alchemia {
    §§ Declaração de variáveis
    (42) --> x atomus;
    (x + 1) --> x;

    §§ Chamada de função sem argumentos
    () saudacao;

    §§ Chamada de função com argumentos
    (x | 10) soma;

    §§ Estruturas condicionais
    (x > 0) si {
        "Positivo" redire;
    } 

    non {
        (x < 0) si {
            "Negativo" redire;
        } 

        (x < 0) si {
            "Negativo" redire;
        } 

        non {
        "Zero" redire;
        }
    }
    
    (x < 0) si {
        "Negativo" redire;
    } 
    non (x == 0) si {
        "Nulo" redire;
    }

    §§ Estruturas de repetição
    (x > 0) persisto {
        x - 1 --> x atomus;
    }

    (0 --> i atomus; i < 10; i + 1 --> i) iterare {
        (i == 10) si {
            10 redire;
        }
    }

    §§ Operadores lógicos e relacionais
    ((x > 0) et (x < 10)) si {
        "Entre 0 e 10" redire;
    }

    ((x == 0) || (x == 10)) si {
        "E zero ou dez" redire;
    }

    ((x > 0) aut (x < 0)) si {
        "Apenas uma condição é verdadeira" redire;
    }

    §§ Operadores matemáticos
    (x + 1) --> resultado atomus;
    (x * 2) --> dobro atomus;
    (x ** 3) --> cubo atomus;

    §§ Input e Output
    a << b << c << lectura;
    x >> y >> z >> revelare;

    (atomus)magnitudo;

    designare atomus int;
    designare quantum bool;

    NomeDaStruct {
        valor1 atomus;
        valor2 fractio;
        1 --> val atomus;
    } designare homunculus;

    2 --> pedra atomus mol;
    "Augustus" --> nome scriptum mol;

   §§ Declaração e uso de arrays 
    vetor1 atomus<<N>>;
    [1 | 2 | 3 | 4] --> vetor1 atomus<<>>;
    [1 | 2 | 3 | 4] --> vetor1 atomus<<N>>;
    [1 | 2 | 3 | 4] --> vetor1;
    [1 | 2 | 3 | 4-->x] --> vetor1 atomus<<N>>;
    array<<N>> --> x atomus;
    4 --> array<<3>>;
    array<<3>> --> x atomus;

    TipoInimigo {
        COMUM
    } enumerare;

    TipoInimigo {
        COMUM 
        | RARO 
        | CHEFE
    } enumerare;

    TipoInimigo {
        COMUM --> 1
        | INCOMUN --> 'a'
        | RARO --> 3
        | CHEFE --> 4
        | PLAYER §§ pega o 5 pois é logo dps do 4 (CHEFE)
    } enumerare;

    RARO --> p TipoInimigo enumerare;

    (p == 3) si {
        "Inimigo Raro" redire;
    }

int main() {
    enum Operacao op = MULTIPLICACAO;
    int a = 5, b = 3, resultado;

    switch (op) {
        case SOMA:
            resultado = a + b;
            break;
        case SUBTRACAO:
            resultado = a - b;
            break;
        case MULTIPLICACAO:
            resultado = a * b;
            break;
        case DIVISAO:
            resultado = a / b;
            break;
        default:
            printf("Operação inválida.\n");
            return 1;
    }

    printf("Resultado: %d\n", resultado);

    return 0;
}



    §§ Retorno de valores
    "Fim do programa" redire;

    §§ Acesso a membros e ponteiros
    objeto.membro --> valor atomus;
    ponteiro->membro --> valor atomus;
}