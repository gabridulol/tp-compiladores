§§ Importação de módulos
io evocare;

§§ Declaração de funções
formula () saudacao --> scriptum {
    "Olá, mundo!" redire;
}

formula (x atomus | y atomus) soma --> atomus {
    (x + y) redire;
}

§§ Função principal
main () Alchemia {
    §§ Declaração de variáveis
    (42) --> x atomus;
    (x + 1) --> x;

    §§ Chamada de função sem argumentos
    () saudacao;

    §§ Chamada de função com argumentos
    (x | 10) soma;

    §§ Estruturas condicionais
    (x > 0) si {
        "Positivo" redire;
    } 

    non {
        (x < 0) si {
            "Negativo" redire;
        } 

        (x < 0) si {
            "Negativo" redire;
        } 

        non {
        "Zero" redire;
        }
    }
    
    (x < 0) si {
        "Negativo" redire;
    } 
    non (x == 0) si {
        "Nulo" redire;
    }

    §§ Estruturas de repetição
    (x > 0) persisto {
        x - 1 --> x atomus;
    }

    (0 --> i atomus; i < 10; i + 1 --> i) iterare {
        (i == 10) si {
            10 redire;
        }
    }

    §§ Operadores lógicos e relacionais
    ((x > 0) et (x < 10)) si {
        "Entre 0 e 10" redire;
    }

    ((x == 0) || (x == 10)) si {
        "E zero ou dez" redire;
    }

    ((x > 0) aut (x < 0)) si {
        "Apenas uma condição é verdadeira" redire;
    }

    §§ Operadores matemáticos
    (x + 1) --> resultado atomus;
    (x * 2) --> dobro atomus;
    (x ** 3) --> cubo atomus;

    §§ Input e Output
    a << b << c << lectura;
    x >> y >> z >> revelare;

    (atomus)magnitudo;

    designare atomus int;
    designare quantum bool;

    NomeDaStruct {
        valor1 atomus;
        valor2 fractio;
        1 --> val atomus;
    } designare homunculus;

    2 --> pedra atomus mol;
    "Augustus" --> nome scriptum mol;

   §§ Declaração e uso de arrays 
    vetor1 atomus<<N>>;
    [1 | 2 | 3 | 4] --> vetor1 atomus<<>>;
    [1 | 2 | 3 | 4] --> vetor1 atomus<<N>>;
    [1 | 2 | 3 | 4] --> vetor1;
    [1 | 2 | 3 | 4-->x] --> vetor1 atomus<<N>>;
    array<<N>> --> x atomus;
    4 --> array<<3>>;
    array<<3>> --> x atomus;

    TipoInimigo {
        COMUM
    } enumerare;

    TipoInimigo {
        COMUM 
        | RARO 
        | CHEFE
    } enumerare;

    TipoInimigo {
        COMUM --> 1
        | INCOMUN --> 'a'
        | RARO --> 3
        | CHEFE --> 4
        | PLAYER §§ pega o 5 pois é logo dps do 4 (CHEFE)
    } enumerare;

    RARO --> p TipoInimigo enumerare;

    (p == 3) si {
        "Inimigo Raro" redire;
    }

    (posicao) vertere {
        casus 1 -> "primeiro lugar" --> resultado; ruptio;
        casus 2 -> "segundo lugar" --> resultado; ruptio;
        casus 3 -> "terceiro lugar" --> resultado; ruptio;
        axiom -> "fora do pódio" --> resultado;
    }

    §§ Declaração de ponteiro
    §§int* a;
    a °atomus;
    2 --> a °atomus;

    §§ Atribuição de endereço
    §§a = &b;
    b£ --> a;

    §§ Desreferenciação 
    §§x = *a;
    °a --> x;

    §§ Acesso a membro direto 
    §§a.nome; 
    a.nome;
    a.nome --> x;

    §§  Acesso com desreferenciação 
    §§(a*).nome;
    (°a).nome;

    §§ Acesso simplificado via ponteiro 
    §§a -> nome;
    a ==> nome;

    §§ Retorno de valores
    "Fim do programa" redire;
}