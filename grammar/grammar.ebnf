// ### Estrutura Geral ###
programa ::= {declaracao} {comando}

// ### Declarações ###
declaracao ::= declaracao_variavel | declaracao_funcao | declaracao_tipo | declaracao_designacao

declaracao_tipo ::= declaracao_homunculus | declaracao_enumeracao

// struct
declaracao_homunculus ::= IDENTIFIER '{' {declaracao_variavel} '}' 'homunculus' ';'

// enum
declaracao_enumeracao ::= IDENTIFIER '{' IDENTIFIER {'|' IDENTIFIER} '}' 'Enumerare' ';'

// typedef
declaracao_designacao ::= tipo IDENTIFIER 'designare' ';'

declaracao_variavel ::= [ 'mol' ] IDENTIFIER tipo [ '-->' expressao ] ';'
declaracao_funcao ::= 'formula' '(' [ lista_parametros ] ')' IDENTIFIER '-->' tipo '{' programa '}'

// ### Tipos ###
tipo ::= nome_tipo_base | tipo '°' | tipo '<<' [ expressao ] '>>' // Array
nome_tipo_base ::= 'vacuum' | 'atomus' | 'fragmentum' | 'fractio' | 'quantum' | 'magnus' | 'minimus' | 'symbolum' | 'scriptum' | IDENTIFIER

// ### Parâmetros de Função ###
lista_parametros ::= parametro { '|' parametro }
parametro ::= IDENTIFIER tipo

// ### Comandos ###
// Define as ações executáveis da linguagem.

comando ::= comando_condicional
          | comando_repeticao
          | comando_iteracao      // For loop
          | comando_selecao       // Switch case
          | comando_retorno ';'
          | comando_atribuicao ';'
          | chamada_funcao ';'
          | comando_ruptio        // Break
          | comando_continuum     // Continue
          | comando_leitura       // Scanf
          | comando_revelacao     // Printf
          | '{' programa '}'      // Bloco de escopo
          | ';'                   // Comando vazio

// A atribuição é um fluxo da direita para a esquerda.
comando_atribuicao ::= expressao '-->' expressao_posfixa

// O comando condicional usa 'si' e 'non'.
comando_condicional ::= '(' expressao ')' 'si' comando [ 'non' comando ]

// Comando de repetição.
comando_repeticao ::= '(' expressao ')' 'persisto' comando

// Comando for
comando_iteracao ::= '(' [comando_atribuicao] ';' [expressao] ';' [expressao] ')' 'iterare' comando

// Comando switch 
comando_selecao ::= '(' expressao ')' 'vertere'  '{' {caso} [caso_padrao] '}'

// Comando de retorno de função.
comando_retorno ::= [ expressao ] 'redire' 

// Regras de suporte para 'vertere' = switch Case
caso ::= 'casus' expressao '->' {comando}
caso_padrao ::= 'axiom' '->' {comando}

// Comando para Break
comando_ruptio ::= 'ruptio' ';'

// Comando para Continue
comando_continuum ::= 'continuum' ';'

// Comando para scanf
comando_leitura ::= '(' expressao_posfixa ')' 'lectura' ';'

// Comando para printf
comando_revelacao ::= '(' expressao ')' 'revelare' ';'

// ### Expressões ###
// Regra inicial para expressões.
expressao ::= expressao_logica_vel

// Operador Lógico OR: aceita 'vel' ou '||'
expressao_logica_vel ::= expressao_logica_et { ( 'vel' | '||' ) expressao_logica_et }

// Operador Lógico AND: aceita 'et' ou '&&'
expressao_logica_et ::= expressao_xor { ( 'et' | '&&' ) expressao_xor }

// Operador Lógico XOR: aceita 'aut' ou '^'
expressao_xor ::= expressao_relacional { ( 'aut' | '^' ) expressao_relacional }

// Operadores Relacionais 
expressao_relacional ::= expressao_aritmetica [ ( '==' | '!=' | '<' | '>' | '<=' | '>=' ) expressao_aritmetica ]

// Operadores Aritméticos de Adição/Subtração
expressao_aritmetica ::= termo { ( '+' | '-' ) termo }

// Operadores de Multiplicação/Divisão (incluindo divisão inteira)
termo ::= fator_exponencial { ( '*' | '/' | '%' | '//' ) fator_exponencial }

// Operador Aritmético de Exponenciação
fator_exponencial ::= expressao_posfixa { '**' fator_exponencial }

// Operadores Unários de Prefixo
fator ::= '(' tipo ')' fator // Type Cast
        | expressao_posfixa
        | '°' fator           // Dereferência
        | ( 'ne' | '!' ) fator  // Negação lógica: aceita 'ne' ou '!'
        | '-' fator           // Negação aritmética

// Operadores de Pós-fixo (Acesso a membros, endereço de uma variável, etc.)
expressao_posfixa ::= primario { sufixo_posfixo }

sufixo_posfixo ::= '.' IDENTIFIER          // Acesso a membro: a.nome
                 | '==>' IDENTIFIER        // Acesso via ponteiro: a==>nome
                 | '£'                     // Endereço de: a£
                 | '<<' expressao '>>'     // Acesso a vetor, por exemplo: a<<3>>

// Elementos Básicos de uma Expressão
primario ::= IDENTIFIER
           | LIT_INT
           | LIT_FLOAT
           | LIT_STRING
           | LIT_FACTUM
           | LIT_FICTUM
           | '(' expressao ')'
           | chamada_funcao
           | expressao_magnitudo // Sizeof

// Aceita tanto tipo quanto variável
expressao_magnitudo ::= 'magnitudo' '(' ( tipo | expressao ) ')'

// A chamada de função mantém a sintaxe invertida
chamada_funcao ::= '(' [ lista_argumentos ] ')' IDENTIFIER
lista_argumentos ::= expressao { '|' expressao }
// ### Estrutura Geral ###
programa ::= {declaracao} {comando}

// ### Declarações ###
declaracao ::= declaracao_variavel | declaracao_funcao | declaracao_tipo | declaracao_designacao

declaracao_tipo ::= declaracao_homunculus | declaracao_enumeracao

// struct
declaracao_homunculus ::= IDENTIFIER '{' {declaracao_variavel} '}' 'homunculus' ';'

// enum
declaracao_enumeracao ::= IDENTIFIER '{' IDENTIFIER {'|' IDENTIFIER} '}' 'Enumerare' ';'

// typedef
declaracao_designacao ::= tipo IDENTIFIER 'designare' ';'

declaracao_variavel ::= [ 'mol' ] IDENTIFIER tipo [ '-->' expressao ] ';'
declaracao_funcao ::= 'formula' '(' [ lista_parametros ] ')' IDENTIFIER '-->' tipo '{' programa '}'

// ### Tipos ###
tipo ::= nome_tipo_base | tipo '°' | tipo '<<' [ expressao ] '>>' // Array
nome_tipo_base ::= 'vacuum' | 'atomus' | 'fragmentum' | 'fractio' | 'quantum' | 'magnus' | 'minimus' | 'symbolum' | 'scriptum' | IDENTIFIER

// ### Parâmetros de Função ###
lista_parametros ::= parametro { '|' parametro }
parametro ::= IDENTIFIER tipo

// ### Comandos ###
// Define as ações executáveis da linguagem.

comando ::= comando_condicional
          | comando_repeticao
          | comando_iteracao      // For loop
          | comando_selecao       // Switch case
          | comando_retorno ';'
          | comando_atribuicao ';'
          | chamada_funcao ';'
          | comando_ruptio        // Break
          | comando_continuum     // Continue
          | comando_leitura       // Scanf
          | comando_revelacao     // Printf
          | '{' programa '}'      // Bloco de escopo
          | ';'                   // Comando vazio

// A atribuição é um fluxo da direita para a esquerda.
comando_atribuicao ::= expressao '-->' expressao_posfixa

// O comando condicional usa 'si' e 'non'.
comando_condicional ::= '(' expressao ')' 'si' comando [ 'non' comando ]

// Comando de repetição.
comando_repeticao ::= '(' expressao ')' 'persisto' comando

// Comando for
comando_iteracao ::= '(' [comando_atribuicao] ';' [expressao] ';' [expressao] ')' 'iterare' comando

// Comando switch 
comando_selecao ::= '(' expressao ')' 'vertere'  '{' {caso} [caso_padrao] '}'

// Comando de retorno de função.
comando_retorno ::= [ expressao ] 'redire' 

// Regras de suporte para 'vertere' = switch Case
caso ::= 'casus' expressao '->' {comando}
caso_padrao ::= 'axiom' '->' {comando}

// Comando para Break
comando_ruptio ::= 'ruptio' ';'

// Comando para Continue
comando_continuum ::= 'continuum' ';'

// Comando para scanf
comando_leitura ::= '(' expressao_posfixa ')' 'lectura' ';'

// Comando para printf
comando_revelacao ::= '(' expressao ')' 'revelare' ';'

// ### Expressões ###
// Regra inicial para expressões.
expressao ::= expressao_logica_vel

// Operador Lógico OR: aceita 'vel' ou '||'
expressao_logica_vel ::= expressao_logica_et { ( 'vel' | '||' ) expressao_logica_et }

// Operador Lógico AND: aceita 'et' ou '&&'
expressao_logica_et ::= expressao_xor { ( 'et' | '&&' ) expressao_xor }

// Operador Lógico XOR: aceita 'aut' ou '^'
expressao_xor ::= expressao_relacional { ( 'aut' | '^' ) expressao_relacional }

// Operadores Relacionais 
expressao_relacional ::= expressao_aritmetica [ ( '==' | '!=' | '<' | '>' | '<=' | '>=' ) expressao_aritmetica ]

// Operadores Aritméticos de Adição/Subtração
expressao_aritmetica ::= termo { ( '+' | '-' ) termo }

// Operadores de Multiplicação/Divisão (incluindo divisão inteira)
termo ::= fator_exponencial { ( '*' | '/' | '%' | '//' ) fator_exponencial }

// Operador Aritmético de Exponenciação
fator_exponencial ::= expressao_posfixa { '**' fator_exponencial }

// Operadores Unários de Prefixo
fator ::= '(' tipo ')' fator // Type Cast
        | expressao_posfixa
        | '°' fator           // Dereferência
        | ( 'ne' | '!' ) fator  // Negação lógica: aceita 'ne' ou '!'
        | '-' fator           // Negação aritmética

// Operadores de Pós-fixo (Acesso a membros, endereço de uma variável, etc.)
expressao_posfixa ::= primario { sufixo_posfixo }

sufixo_posfixo ::= '.' IDENTIFIER          // Acesso a membro: a.nome
                 | '==>' IDENTIFIER        // Acesso via ponteiro: a==>nome
                 | '£'                     // Endereço de: a£
                 | '<<' expressao '>>'     // Acesso a vetor, por exemplo: a<<3>>

// Elementos Básicos de uma Expressão
primario ::= IDENTIFIER
           | LIT_INT
           | LIT_FLOAT
           | LIT_STRING
           | LIT_FACTUM
           | LIT_FICTUM
           | '(' expressao ')'
           | chamada_funcao
           | expressao_magnitudo // Sizeof

// Aceita tanto tipo quanto variável
expressao_magnitudo ::= 'magnitudo' '(' ( tipo | expressao ) ')'

// A chamada de função mantém a sintaxe invertida
chamada_funcao ::= '(' [ lista_argumentos ] ')' IDENTIFIER
lista_argumentos ::= expressao { '|' expressao }
